'use strict';

var net = require('net');
var cluster = require('cluster');
var crypto = require('crypto');
var sha512 = null;
var cfg = require('app/tools/readArgv').init(process);
var logWrapper = require('app/tools/logWrapper');
var uniqid = require('app/tools/uniqid');
var connections = [];
var elevatedConnections = [];
var serverSubscribers = [];
var serverList = [];
var callbackHashTable = {};
var loggedinUsers = {};

var logoutUser = function(c){
    let requestID = uniqid.next();
    let request = {
        'method':['logout'],
        'param':[{
            '$':{
                'sessid':((c.sessid!=null)?c.sessid:"doesn't exist")
            }
        }]
    };

    callbackHashTable['c2sWorker'+requestID] = function(){
        delete callbackHashTable['c2sWorker'+requestID];
    };
    process.send({
        messageType:"c2sMaster",
        payload:{
            reqID:requestID,
            workerID:cluster.worker.id,
            data:request
        }
    });
};

var endConnection = function(c){
    if (c.ended==null) {
        logoutUser(c);

        c.ended = true;
        let idxConn = connections.indexOf(c);
        if (idxConn>-1) {
            connections.splice(idxConn,1);
        }
        let idxElev = elevatedConnections.indexOf(c);
        if (idxElev>-1) {
            elevatedConnections.splice(idxElev,1);
        }
        let idxSubs = serverSubscribers.indexOf(c);
        if (idxSubs>-1) {
            serverSubscribers.splice(idxSubs,1);
        }
        c.end();
    }
};

var telnetServer = net.createServer(function(c){
    let defaultTimeout = 5*60; // in seconds
    connections.push(c);
    c.buffer = "";

    let executeChecker = function(){
        let checker = setInterval(function(){
            if (c.ended==null) {
                if (c.lastBytesRead==null) {
                    c.lastBytesRead = c.bytesRead;
                    c.iddleCounter = 0;
                } else {
                    if (c.lastBytesRead===c.bytesRead) {
                        c.iddleCounter++;
                    } else {
                        c.lastBytesRead = c.bytesRead;
                        c.iddleCounter = 0;
                        console.log("cleared");
                    }
                }
                if (c.iddleCounter>=defaultTimeout) {
                    clearInterval(checker);
                    endConnection(c);
                }
            }
        }, 1000);
    };
    executeChecker();

    c.on('data', function(data){
        if (c.ended==null) {
            let str = data.toString();
            if (str.length===1 && str.charCodeAt(0)===8) {
                if (c.buffer.length>0) {
                    c.buffer = c.buffer.substring(0,c.buffer.length-1);
                }
            } else {
                if (str.search("\r")>-1 || str.search("\n")>-1) {
                    str = c.buffer + str;
                    c.buffer = '';

                    data = str.replace(/\r/g, "").replace(/\n/g, "").replace(/\\;/g, "::semicolon::").split(";");
                    for (let i = 0; i < data.length; i++) {
                        data[i] = data[i].trim().replace(/::semicolon::/g, ";");
                    }
                    switch (data[0]) {
                        case 'timeout': {
                            if (data.length===2) {
                                let t = parseInt(data[1]);
                                if (!isNaN(t)) {
                                    defaultTimeout = t;
                                    c.write("{accepted}\r\n");
                                }
                            }
                        } break;
                        case 'register': {
                            if (data.length===3) {
                                let requestID = uniqid.next();
                                let hash = null;
                                let request = {
                                    'method':['register'],
                                    'param':[{
                                        '$':{
                                            'user':data[1],
                                            'password':data[2]
                                        }
                                    }]
                                };
                                sha512 = crypto.createHash('sha512');
                                sha512.update(request.param[0].$.password);
                                hash = sha512.digest('hex');

                                callbackHashTable['c2sWorker'+requestID] = function(data){
                                    let res = data.data.response;
                                    if (res.message!=null) {
                                        c.write("{" + res.status[0] + "}");
                                        c.write(" " + res.message[0]);
                                        c.write("\r\n");
                                    } else {
                                        c.write("{" + res.status[0] + "}");
                                        c.write("\r\n");
                                    }

                                    delete callbackHashTable['c2sWorker'+requestID];
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        workerID:cluster.worker.id,
                                        reqID:requestID,
                                        hash:hash,
                                        data:request
                                    }
                                });
                            } else {
                                c.write("Error: please specify username and password!\r\n");
                            }
                        } break;
                        case 'login': {
                            if (c.sessid!=null) {
                                c.write('{rejected} you\'re already logged-in\r\n');
                            } else {
                                if (data.length===3) {
                                    let requestID = uniqid.next();
                                    let hash = null;
                                    let sessid = null;
                                    let request = {
                                        'method':['login'],
                                        'param':[{
                                            '$':{
                                                'user':data[1],
                                                'password':data[2]
                                            }
                                        }]
                                    };
                                    sha512 = crypto.createHash('sha512');
                                    sha512.update(request.param[0].$.password);
                                    hash = sha512.digest('hex');
                                    sessid = request.param[0].$.user + "::w" + cluster.worker.id + "::" + crypto.randomBytes(16).toString('base64');

                                    callbackHashTable['c2sWorker'+requestID] = function(data){
                                        let res = data.data.response;
                                        if (res.message!=null) {
                                            c.write("{" + res.status[0] + "}");
                                            c.write(" " + res.message[0]);
                                            c.write("\r\n");
                                        } else {
                                            c.write("{" + res.status[0] + "}");
                                            c.write("\r\n");
                                            for (let i = 0; i < connections.length; i++) {
                                                if (connections[i]===c) {
                                                    connections.splice(i,1);
                                                }
                                            }
                                            c.sessid = res.sessid[0];
                                            elevatedConnections.push(c);
                                        }

                                        delete callbackHashTable['c2sWorker'+requestID];
                                    };
                                    process.send({
                                        messageType:"c2sMaster",
                                        payload:{
                                            workerID:cluster.worker.id,
                                            reqID:requestID,
                                            hash:hash,
                                            sessid:sessid,
                                            data:request
                                        }
                                    });
                                } else {
                                    c.write("Error: please specify username and password!\r\n");
                                }
                            }
                        } break;
                        case 'logout': {
                            if (c.sessid!=null) {
                                let requestID = uniqid.next();
                                let request = {
                                    'method':['logout'],
                                    'param':[{
                                        '$':{
                                            'sessid':((c.sessid!=null)?c.sessid:"doesn't exist")
                                        }
                                    }]
                                };

                                callbackHashTable['c2sWorker'+requestID] = function(data){
                                    let res = data.data.response;
                                    if (res.message!=null) {
                                        c.write("{" + res.status[0] + "}");
                                        c.write(" " + res.message[0]);
                                        c.write("\r\n");
                                    } else {
                                        c.write("{" + res.status[0] + "}");
                                        c.write("\r\n");
                                        let idxElev = elevatedConnections.indexOf(c);
                                        if (idxElev>-1) {
                                            elevatedConnections.splice(idxElev,1);
                                        }
                                        let idxSubs = serverSubscribers.indexOf(c);
                                        if (idxSubs>-1) {
                                            serverSubscribers.splice(idxSubs,1);
                                        }
                                        c.end("{connection is closed}\r\n");
                                    }

                                    delete callbackHashTable['c2sWorker'+requestID];
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        reqID:requestID,
                                        workerID:cluster.worker.id,
                                        data:request
                                    }
                                });
                            } else {
                                c.write("{rejected} you are not logged-in\r\n");
                            }
                        } break;
                        case 'exit': {
                            c.write("{accepted}\r\n");
                            c.end("{connection is closed}\r\n");
                        } break;
                        case 'chatsend': {
                            if (data.length===2) {
                                let requestID = uniqid.next();
                                let request = {
                                    'method':['chatSend'],
                                    'param':[{
                                        '$':{
                                            'sessid':((c.sessid!=null)?c.sessid:"doesn't exist"),
                                            'message':data[1]
                                        }
                                    }]
                                };

                                callbackHashTable['c2sWorker'+requestID] = function(data){
                                    let res = data.data.response;
                                    if (res.message!=null) {
                                        c.write("{" + res.status[0] + "}");
                                        c.write(" " + res.message[0]);
                                        c.write("\r\n");
                                    } else {
                                        c.write("{" + res.status[0] + "}");
                                        c.write("\r\n");
                                    }

                                    delete callbackHashTable['c2sWorker'+requestID];
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        reqID:requestID,
                                        workerID:cluster.worker.id,
                                        data:request
                                    }
                                });
                            } else {
                                if (data.length===1) {
                                    c.write("Error: please write a message!\r\n");
                                } else {
                                    c.write("Error: don't use ';' in your message!\r\n");
                                }
                            }
                        } break;
                        case 'chatget': {
                            if (data.length===2) {
                                let requestID = uniqid.next();
                                let request = {
                                    'method':['chatGet'],
                                    'param':[{
                                        '$':{
                                            'time':data[1]
                                        }
                                    }]
                                };

                                callbackHashTable['c2sWorker'+requestID] = function(data){
                                    let res = data.data.response;
                                    if (res.message!=null) {
                                        c.write("{" + res.status[0] + "}");
                                        c.write(" " + res.message[0]);
                                        c.write("\r\n");
                                    } else {
                                        c.write("{" + res.status[0] + "}");
                                        c.write("\r\n");
                                        if (res.messages!=null && res.messages.length>0) {
                                            for (let i = res.messages[0].message.length-1; i >= 0; i--) {
                                                c.write(
                                                    "[" + res.messages[0].message[i].$.time + "] <" + res.messages[0].message[i].$.username + ">: " +
                                                    res.messages[0].message[i].$.message + "\r\n"
                                                );
                                            }
                                        } else {
                                            c.write('{no messages}\r\n');
                                        }
                                    }

                                    delete callbackHashTable['c2sWorker'+requestID];
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        reqID:requestID,
                                        workerID:cluster.worker.id,
                                        data:request
                                    }
                                });
                            } else if (data.length===3 && data[2]==="withuserhistory") {
                                var chatgetData = null;
                                var userhistoryData = null;
                                var totalCalled = 0;
                                var aggregatedCallback = function(){
                                    let timeline = [];
                                    let res = chatgetData.data.response;
                                    if (res.messages!=null && res.messages.length>0) {
                                        for (let i = res.messages[0].message.length-1; i >= 0; i--) {
                                            timeline.push({
                                                "type":"chatget",
                                                "username":res.messages[0].message[i].$.username,
                                                "timestamp":parseInt(res.messages[0].message[i].$.time),
                                                "message":res.messages[0].message[i].$.message
                                            });
                                        }
                                    }
                                    res = userhistoryData.data.response;
                                    if (res.userHistories!=null && res.userHistories.length>0) {
                                        for (let i = res.userHistories[0].userHistory.length-1; i >= 0; i--) {
                                            let action = res.userHistories[0].userHistory[i].$.action;
                                            if (action==="LOGIN") {
                                                action = "logged-in";
                                            } else {
                                                action = "logged-out";
                                            }
                                            timeline.push({
                                                "type":"userhistory",
                                                "username":res.userHistories[0].userHistory[i].$.username,
                                                "timestamp":parseInt(res.userHistories[0].userHistory[i].$.timestamp),
                                                "action":action
                                            });
                                        }
                                    }
                                    timeline.sort(function(a, b){
                                        return a.timestamp - b.timestamp;
                                    });

                                    c.write("{accepted}");
                                    c.write("\r\n");
                                    for (let i = 0; i < timeline.length; i++) {
                                        switch(timeline[i].type) {
                                            case "chatget": {
                                                c.write(
                                                    "[" + timeline[i].timestamp + "] <" + timeline[i].username + ">: " +
                                                    timeline[i].message + "\r\n"
                                                );
                                            } break;
                                            case "userhistory": {
                                                c.write(
                                                    "<" + timeline[i].username + ">: " +
                                                    timeline[i].action + "\r\n"
                                                );
                                            } break;
                                        }
                                    }
                                };

                                // CHATGET PORTION
                                let requestIDChatGet = uniqid.next();
                                let requestChatGet = {
                                    'method':['chatGet'],
                                    'param':[{
                                        '$':{
                                            'time':data[1]
                                        }
                                    }]
                                };

                                callbackHashTable['c2sWorker'+requestIDChatGet] = function(data){
                                    delete callbackHashTable['c2sWorker'+requestIDChatGet];
                                    totalCalled++;
                                    chatgetData = data;
                                    if (totalCalled===2) {
                                        aggregatedCallback();
                                    }
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        reqID:requestIDChatGet,
                                        workerID:cluster.worker.id,
                                        data:requestChatGet
                                    }
                                });

                                // USERHISTORY PORTION
                                let requestIDUserHistory = uniqid.next();
                                let requestUserHistory = {
                                    'method':['getUserHistory'],
                                    'param':[{
                                        '$':{
                                            'time':data[1]
                                        }
                                    }]
                                };

                                callbackHashTable['c2sWorker'+requestIDUserHistory] = function(data){
                                    delete callbackHashTable['c2sWorker'+requestIDUserHistory];
                                    totalCalled++;
                                    userhistoryData = data;
                                    if (totalCalled===2) {
                                        aggregatedCallback();
                                    }
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        reqID:requestIDUserHistory,
                                        workerID:cluster.worker.id,
                                        data:requestUserHistory
                                    }
                                });

                            } else {
                                c.write("Error: please specify a time!\r\n");
                            }
                        } break;
                        case 'userhistory': {
                            if (data.length===2) {
                                let requestID = uniqid.next();
                                let request = {
                                    'method':['getUserHistory'],
                                    'param':[{
                                        '$':{
                                            'time':data[1]
                                        }
                                    }]
                                };

                                callbackHashTable['c2sWorker'+requestID] = function(data){
                                    let res = data.data.response;
                                    if (res.message!=null) {
                                        c.write("{" + res.status[0] + "}");
                                        c.write(" " + res.message[0]);
                                        c.write("\r\n");
                                    } else {
                                        c.write("{" + res.status[0] + "}");
                                        c.write("\r\n");
                                        if (res.userHistories!=null && res.userHistories.length>0) {
                                            for (let i = res.userHistories[0].userHistory.length-1; i >= 0; i--) {
                                                let action = res.userHistories[0].userHistory[i].$.action;
                                                if (action==="LOGIN") {
                                                    action = "logged-in";
                                                } else {
                                                    action = "logged-out";
                                                }
                                                c.write(
                                                    "<" + res.userHistories[0].userHistory[i].$.username + ">: " +
                                                    action + " [" + res.userHistories[0].userHistory[i].$.timestamp + "]\r\n"
                                                );
                                            }
                                        } else {
                                            c.write('{no history}\r\n');
                                        }
                                    }

                                    delete callbackHashTable['c2sWorker'+requestID];
                                };
                                process.send({
                                    messageType:"c2sMaster",
                                    payload:{
                                        reqID:requestID,
                                        workerID:cluster.worker.id,
                                        data:request
                                    }
                                });
                            } else {
                                if (data.length===1) {
                                    c.write("Error: please specify a time!\r\n");
                                } else {
                                    c.write("Error: you only need to supply time.\r\n");
                                }
                            }
                        } break;
                        case 'listloggedin': {
                            if (c.sessid!=null) {
                                c.write("{accepted}\r\n");
                                for (let key in loggedinUsers) {
                                    if (loggedinUsers.hasOwnProperty(key)) {
                                        c.write("<" + key + ">: logged-in\r\n");
                                    }
                                }
                            } else {
                                c.write("{rejected} not logged-in\r\n");
                            }
                        } break;
                        case 'serversubscribe': {
                            if (serverSubscribers.indexOf(c)===-1) {
                                serverSubscribers.push(c);
                                c.write("{accepted}\r\n");
                                for (let i = 0; i < serverList.length; i++) {
                                    c.write("Server: "+serverList[i].ip+":"+serverList[i].port+"\r\n");
                                }
                            } else {
                                c.write("{rejected} already subscribed\r\n");
                            }
                        } break;
                    }
                } else {
                    let addToBuffer = true;
                    let ignored = [
                        "279165",
                        "279166",
                        "279167",
                        "279168"
                    ];
                    let s = "";
                    for (let k = 0; k < data.toString().length; k++) {
                        s += data.toString().charCodeAt(k);
                    }
                    for (var l = 0; l < ignored.length; l++) {
                        if (s===ignored[l]) {
                            addToBuffer = false;
                            l = ignored.length;
                        }
                    }

                    if (addToBuffer===true) {
                        c.buffer += str;
                    }
                }
            }
        }
    });

    c.on('end', function(){
        // logWrapper.log("Connection end event.");
        endConnection(c);
    });
    c.on('error', function(){
        // logWrapper.log("Connection error event.");
        endConnection(c);
    });
    c.on('close', function(){
        // logWrapper.log("Connection close event.");
        endConnection(c);
    });
    // c.on('timeout', function(){
    //     logWrapper.log("Connection timeout event.");
    //     endConnection(c);
    // });

    try {
        c.write('Notification: ');
        if (cfg.ip==null) {
            c.write('You are connected to chat server using telnet on port '+cfg.telnetPort+'\r\n');
        } else {
            c.write('You are connected to chat server using telnet on address '+cfg.ip+':'+cfg.telnetPort+'\r\n');
        }
        c.write('Notification: default timeout is ' + defaultTimeout + 's\r\n');
    } catch(e) {
        logWrapper.log("ERROR:");
        logWrapper.log(e);
    }
});
if (cfg.ip==null) {
    telnetServer.listen(cfg.telnetPort);
} else {
    telnetServer.listen(cfg.telnetPort, cfg.ip);
}

process.on('message', function(data){
    if (data.messageType!=null) {
        switch (data.messageType) {
            case "c2sWorker": {
                if (callbackHashTable["c2sWorker"+data.payload.reqID]!=null) {
                    callbackHashTable["c2sWorker"+data.payload.reqID](data.payload);
                }
            } break;
            case "c2sWorkerChatSend": {
                for (let i = 0; i < data.payload.length; i++) {
                    for (let j = 0; j < elevatedConnections.length; j++) {
                        try {
                            elevatedConnections[j].write(
                                "[" + data.payload[i].time + "] <" + data.payload[i].username + ">: " +
                                data.payload[i].message + "\r\n"
                            );
                        } catch(e) {
                            elevatedConnections[j].ended = true;
                            elevatedConnections.splice(j, 1);
                            let idxSubs = serverSubscribers.indexOf(elevatedConnections[j]);
                            if (idxSubs>-1) {
                                serverSubscribers.splice(idxSubs, 1);
                            }
                            logoutUser(elevatedConnections[j]);
                        }
                    }
                }
            } break;
            case "c2sWorkerLogin": {
                for (let i = 0; i < data.payload.length; i++) {
                    if (loggedinUsers[data.payload[i].username]==null) {
                        loggedinUsers[data.payload[i].username] = true;
                    }

                    for (let j = 0; j < elevatedConnections.length; j++) {
                        try {
                            elevatedConnections[j].write(
                                "<" + data.payload[i].username + ">: logged-in\r\n"
                            );
                        } catch(e) {
                            elevatedConnections[i].ended = true;
                            elevatedConnections.splice(i, 1);
                            let idxSubs = serverSubscribers.indexOf(elevatedConnections[i]);
                            if (idxSubs>-1) {
                                serverSubscribers.splice(idxSubs, 1);
                            }
                            logoutUser(elevatedConnections[i]);
                        }
                    }
                }
            } break;
            case "c2sWorkerLogout": {
                for (let i = 0; i < data.payload.length; i++) {
                    if (loggedinUsers[data.payload[i].username]===true) {
                        delete loggedinUsers[data.payload[i].username];
                    }

                    for (let j = 0; j < elevatedConnections.length; j++) {
                        try {
                            elevatedConnections[j].write(
                                "<" + data.payload[i].username + ">: logged-out\r\n"
                            );
                        } catch(e) {
                            elevatedConnections[i].ended = true;
                            elevatedConnections.splice(i, 1);
                            let idxSubs = serverSubscribers.indexOf(elevatedConnections[i]);
                            if (idxSubs>-1) {
                                serverSubscribers.splice(idxSubs, 1);
                            }
                            logoutUser(elevatedConnections[i]);
                        }
                    }
                }
            } break;
            case "serverRegistration": {
                serverList.push(data.payload);
                for (let i = 0; i < serverSubscribers.length; i++) {
                    try {
                        serverSubscribers[i].write("Server: "+data.payload.ip+":"+data.payload.port+"\r\n");
                    } catch(e) {
                        serverSubscribers[i].ended = true;
                        serverSubscribers.splice(i, 1);
                        let idxElev = elevatedConnections.indexOf(serverSubscribers[i]);
                        if (idxElev>-1) {
                            elevatedConnections.splice(idxElev, 1);
                        }
                        let idxConn = connections.indexOf(serverSubscribers[i]);
                        if (idxConn>-1) {
                            connections.splice(idxConn, 1);
                        }
                        if (serverSubscribers[i].sessid!=null) {
                            logoutUser(serverSubscribers[i]);
                        }
                    }
                }
            } break;
        }
    }
});

setInterval(function(){
    var doHeartbeat = function(c){
        let requestID = uniqid.next();
        let request = {
            'method':['heartbeat'],
            'param':[{
                '$':{
                    'sessid':c.sessid
                }
            }]
        };
        callbackHashTable['c2sWorker'+requestID] = function(){
            delete callbackHashTable['c2sWorker'+requestID];
        };
        process.send({
            messageType:"c2sMaster",
            payload:{
                reqID:requestID,
                workerID:cluster.worker.id,
                data:request
            }
        });
    };

    for (let i = 0; i < elevatedConnections.length; i++) {
        if (elevatedConnections[i].sessid!=null) {
            doHeartbeat(elevatedConnections[i]);
        }
    }
}, 3*1000);

// Make sure connections always active
// setInterval(function(){
//     let problems = [];
//     let maxCount = 3;
//     for (let i = 0; i < connections.length; i++) {
//         connections[i].write("\u0000");
//         logWrapper.log("Bytes written: "+connections[i].bytesWritten);
//         if (connections[i].lastBytesWritten==null) {
//             connections[i].lastBytesWritten = connections[i].bytesWritten;
//             connections[i].iddleCount = 0;
//         } else {
//             if (connections[i].lastBytesWritten === connections[i].bytesWritten) {
//                 connections[i].iddleCount++;
//             }
//             connections[i].lastBytesWritten = connections[i].bytesWritten;
//             if (connections[i].iddleCount>=maxCount) {
//                 problems.push(connections[i]);
//             }
//         }
//     }
//     for (let i = 0; i < elevatedConnections.length; i++) {
//         elevatedConnections[i].write("\u0000");
//         logWrapper.log("Bytes written: "+elevatedConnections[i].bytesWritten);
//         if (elevatedConnections[i].lastBytesWritten==null) {
//             elevatedConnections[i].lastBytesWritten = elevatedConnections[i].bytesWritten;
//             elevatedConnections[i].iddleCount = 0;
//         } else {
//             if (elevatedConnections[i].lastBytesWritten === elevatedConnections[i].bytesWritten) {
//                 elevatedConnections[i].iddleCount++;
//             }
//             elevatedConnections[i].lastBytesWritten = elevatedConnections[i].bytesWritten;
//             if (elevatedConnections[i].iddleCount>=maxCount) {
//                 problems.push(elevatedConnections[i]);
//             }
//         }
//     }
//
//     for (let i = 0; i < problems.length; i++) {
//         endConnection(problems[i]);
//     }
// }, 3*1000);
