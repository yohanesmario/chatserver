'use strict';

// Absolute Dependencies
var cc = require('app/tools/clusterCounter');
var numCPUs = cc.numCPUs;
var numWorkers = cc.numWorkers;

// Environment variables
process.env.UV_THREADPOOL_SIZE = numCPUs; // libuv threadpool size

// Common Dependencies
var cluster = require('cluster');

// APP TITLE
console.log("\nHTTP CHAT SERVER\n");

// Master Dependencies
var logWrapper = require('app/tools/logWrapper');
var cfg = require('app/tools/readArgv').init(process);
var promptWrapper = require('app/tools/promptWrapper');
var s2sClient = require('app/s2s/s2sClient');
var dbWrapper = require('app/tools/dbWrapper').init(cfg);
s2sClient.dbWrapper = dbWrapper;
s2sClient.cfg = cfg;
var processPost = require('app/tools/processPost').init(cfg, dbWrapper, s2sClient);

// Set round-robin cluster scheduling
// cluster.schedulingPolicy = cluster.SCHED_RR;

// Load DB.
dbWrapper.loadDatabase(function(){
    var workerCount = 0;

    var startPrompt = function(){
        if (cfg.ip==null) {
            logWrapper.log("All workers are listening on port "+cfg.port);
        } else {
            logWrapper.log("All workers are listening on address "+cfg.ip+":"+cfg.port);
        }
        logWrapper.log("Telnet is accessible at port "+cfg.telnetPort+"\n");

        promptWrapper.startReading(dbWrapper, s2sClient);
        s2sClient.startHeartbeat();
    };

    var workerStartedCallback = function(){
        workerCount++;
        if (workerCount===numWorkers) {
            if (cfg.serverHook!=null) {
                s2sClient.initConnection(cfg, function(){
                    startPrompt();
                });
            } else {
                startPrompt();
            }
        }
    };

    // Fork workers.
    var workerMessageCallback = function(data){
        if (data.messageType!=null) {
            switch (data.messageType) {
                case "c2sMaster": {
                    processPost.c2s.handle(data.payload);
                } break;
                case "s2sMaster": {
                    processPost.s2s.handle(data.payload);
                } break;
                case "workerStarted": {
                    workerStartedCallback();
                } break;
                case "initWorker": {
                    processPost.c2s.initWorker(data.payload.workerID);
                } break;
                case "log": {
                    logWrapper.log(data.payload);
                } break;
            }
        }
    };
    for (var i = 0; i < numWorkers; i++) {
        var worker = cluster.fork();
        worker.on('message', workerMessageCallback);
    }

    cluster.on('exit', function(worker) {
        var newWorker = cluster.fork();
        logWrapper.log('worker ' + worker.id + ' [' + worker.process.pid + '] died.');
        logWrapper.log('worker ' + newWorker.id  + ' [' + newWorker.process.pid + '] created.');
    });
});
