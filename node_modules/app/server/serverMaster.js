'use strict';

// Absolute Dependencies
var cc = require('app/tools/clusterCounter');
var numCPUs = cc.numCPUs;
var numWorkers = cc.numWorkers;

// Environment variables
process.env.UV_THREADPOOL_SIZE = numCPUs; // libuv threadpool size

// Common Dependencies
var cluster = require('cluster');

// APP TITLE
console.log("\nHTTP CHAT SERVER\n");

// Master Dependencies
var logWrapper = require('app/tools/logWrapper');
var cfg = require('app/tools/readArgv').init(process);
var promptWrapper = require('app/tools/promptWrapper');
var s2sClient = require('app/s2s/s2sClient');
var dbWrapper = require('app/tools/dbWrapper').init(cfg);
s2sClient.dbWrapper = dbWrapper;
s2sClient.cfg = cfg;
var processPost = require('app/tools/processPost').init(cfg, dbWrapper, s2sClient);
var workerType = require('app/tools/workerType');
var workerSet = {};

// Set round-robin cluster scheduling
// cluster.schedulingPolicy = cluster.SCHED_RR;

// Figure out whether to act as Master or Slave server.
s2sClient.probeHooks(cfg, function(connected){
    if (connected===true) {
        cfg.persistDB = false;
        console.log("Not the first server in this chat network. Clearing database...");
    } else {
        cfg.persistDB = true;
        console.log("First server in this chat network. Loading backup database...");
    }

    // Load DB.
    dbWrapper.loadDatabase(function(){
        var workerCount = 0;
        var allWorkerStarted = false;
        var initCrash = false;

        var startPrompt = function(){
            if (cfg.ip==null) {
                if (cc.numHTTP>1) {
                    console.log("HTTP workers are listening on port "+cfg.port);
                } else {
                    console.log("HTTP worker is listening on port "+cfg.port);
                }
                if (cc.numTelnet>1) {
                    console.log("Telnet workers are listening on port "+cfg.telnetPort+"\n");
                } else {
                    console.log("Telnet worker is listening on port "+cfg.telnetPort+"\n");
                }
            } else {
                if (cc.numHTTP>1) {
                    console.log("HTTP workers are listening on address "+cfg.ip+":"+cfg.port);
                } else {
                    console.log("HTTP worker is listening on address "+cfg.ip+":"+cfg.port);
                }
                if (cc.numTelnet>1) {
                    console.log("Telnet workers are listening on address "+cfg.ip+":"+cfg.telnetPort+"\n");
                } else {
                    console.log("Telnet worker is listening on address "+cfg.ip+":"+cfg.telnetPort+"\n");
                }
            }

            promptWrapper.startReading(dbWrapper, s2sClient);
            s2sClient.startHeartbeat();
        };

        var workerStartedCallback = function(){
            workerCount++;
            if (workerCount===numWorkers) {
                for (let key in cluster.workers) {
                    if (cluster.workers.hasOwnProperty(key)) {
                        cluster.workers[key].send({
                            messageType:"serverRegistration",
                            payload:{
                                "ip":cfg.identifier.ip,
                                "port":cfg.identifier.port
                            }
                        });
                    }
                }
                if (cfg.serverHook!=null) {
                    s2sClient.initConnection(cfg, function(){
                        startPrompt();
                    });
                } else {
                    cfg.config.serverHook = [];
                    cfg.serverHook = [];
                    dbWrapper.queueSaving();
                    startPrompt();
                }
                allWorkerStarted = true;
            }
        };

        var workerMessageCallback = function(data){
            if (data!=null && data.messageType!=null) {
                switch (data.messageType) {
                    case "c2sMaster": {
                        processPost.c2s.handle(data.payload);
                    } break;
                    case "s2sMaster": {
                        processPost.s2s.handle(data.payload);
                    } break;
                    case "workerStarted": {
                        workerStartedCallback();
                    } break;
                    case "initWorker": {
                        processPost.c2s.initWorker(data.payload.workerID);
                    } break;
                    case "log": {
                        logWrapper.log(data.payload);
                    } break;
                    case "whoAmI": {
                        if (data.payload!=null && data.payload.workerID!=null) {
                            cluster.workers[data.payload.workerID].send({
                                "messageType":"youAre",
                                "payload":{
                                    "workerType":workerSet[data.payload.workerID+""]
                                }
                            });
                        }
                    } break;
                }
            }
        };

        cluster.on('exit', function(worker) {
            if (allWorkerStarted===true && initCrash===false) {
                var newWorker = cluster.fork();
                newWorker.on('message', workerMessageCallback);
                workerSet[newWorker.id+""] = workerSet[worker.id+""];
                delete workerSet[worker.id+""];
                logWrapper.log('worker ' + worker.id + ' [' + worker.process.pid + '] died.');
                logWrapper.log('worker ' + newWorker.id  + ' [' + newWorker.process.pid + '] created.');
            } else {
                if (initCrash===false) {
                    initCrash = true;
                    setTimeout(function(){
                        console.log("\r\n\r\nFATAL ERROR: Unable to start server. Please check your configurations.");
                        process.exit(0);
                    }, 500);
                }
            }
        });

        // Assign worker type.
        let workerIdx = 1;
        for (let i = 0; i < cc.numHTTP; i++) {
            workerSet[workerIdx+""] = workerType.TYPE_HTTP;
            workerIdx++;
        }
        for (let i = 0; i < cc.numTelnet; i++) {
            workerSet[workerIdx+""] = workerType.TYPE_TELNET;
            workerIdx++;
        }
        console.log("\nWorker pool:");
        if (cc.numHTTP>1) {
            console.log("HTTP  : "+cc.numHTTP+" workers");
        } else {
            console.log("HTTP  : "+cc.numHTTP+" worker");
        }
        if (cc.numTelnet>1) {
            console.log("Telnet: "+cc.numTelnet+" workers\n");
        } else {
            console.log("Telnet: "+cc.numTelnet+" worker\n");
        }

        // Fork workers.
        for (let i = 0; i < numWorkers; i++) {
            var worker = cluster.fork();
            worker.on('message', workerMessageCallback);
        }
    });
});
